var documenterSearchIndex = {"docs":
[{"location":"man/algs.html#Quantum-Algorithms-for-Differential-Equations-1","page":"Quantum Algorithms for Differential Equations","title":"Quantum Algorithms for Differential Equations","text":"","category":"section"},{"location":"man/algs.html#Taylor-truncation-based-algorithms-1","page":"Quantum Algorithms for Differential Equations","title":"Taylor truncation based algorithms","text":"","category":"section"},{"location":"man/algs.html#","page":"Quantum Algorithms for Differential Equations","title":"Quantum Algorithms for Differential Equations","text":"QuDiffEq.QuLDE\nQuDiffEq.QuNLDE","category":"page"},{"location":"man/algs.html#QuDiffEq.QuLDE","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuLDE","text":"QuLDE <: QuODEAlgorithm\n\nLinear differential equation solvers (non-HHL)     * k : order of Taylor series expansion\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuNLDE","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuNLDE","text":"QuNLDE <: QuODEAlgorithm\n\nLinear differential equation solvers (non-HHL)     * k : order of Taylor series expansion     * ϵ : precision\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#HHL-based-algorithms-1","page":"Quantum Algorithms for Differential Equations","title":"HHL based algorithms","text":"","category":"section"},{"location":"man/algs.html#","page":"Quantum Algorithms for Differential Equations","title":"Quantum Algorithms for Differential Equations","text":"The following algorithms are in the reference, arxiv.org/abs/1010.2745v2 .","category":"page"},{"location":"man/algs.html#","page":"Quantum Algorithms for Differential Equations","title":"Quantum Algorithms for Differential Equations","text":"QuDiffEq.LDEMSAlgHHL\nQuDiffEq.QuEuler\nQuDiffEq.QuLeapfrog\nQuDiffEq.QuAB2\nQuDiffEq.QuAB3\nQuDiffEq.QuAB4","category":"page"},{"location":"man/algs.html#QuDiffEq.LDEMSAlgHHL","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.LDEMSAlgHHL","text":"LDEMSAlgHHL <: QuODEAlgorithm\n\nMulti-step methods based on HHL\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuEuler","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuEuler","text":"QuEuler{T} <: LDEMSAlgHHL\n\nEuler Method using HHL (1-step method)\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuLeapfrog","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuLeapfrog","text":"QuLeapfrog{T} <: LDEMSAlgHHL\n\nLeapfrog Method using HHL (2-step method)\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuAB2","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuAB2","text":"QuAB2{T} <: LDEMSAlgHHL\n\nAB2 Method using HHL (2-step method)\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuAB3","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuAB3","text":"QuAB3{T} <: LDEMSAlgHHL\n\nAB3 Method using HHL (3-step method)\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuAB4","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuAB4","text":"QuAB4{T} <: LDEMSAlgHHL\n\nAB4 Method using HHL (4-step method)\n\n\n\n\n\n","category":"type"},{"location":"tutorial/lin.html#Linear-Differential-Equations-1","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"","category":"section"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"A linear differential equation is written as","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":" fracdxdt = Mx + b","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"M is an arbitrary N × N matrix, x and b are N dimensional vectors.","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"QuDiffEq allows for the following methods of solving a linear differential equation:","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"QuLDE: LDE algorithm based on Taylor Truncation. This method evaluates the vector at the last time step, without going through the intermediate steps, unlike other solvers.","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"The exact solution for x(t) is give by -","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":" x(t) = e^Mtx(0) + (e^Mt - I)M^-1b","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"This can be Taylor expanded up to the k^thorder as -","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"x(t) approx sum^k_m=0frac(Mt)^mmx(0) + sum^k-1_n=1frac(Mt)^n-1tnb","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"The vectors x(0) and b are encoded as state - x(0)rangle = sum_i fracx_ix irangle and brangle = sum_i fracb_ib irangle with i rangleas the computational basis states. We can also write M as M = MmathcalM. We then get:","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"x(t)rangle approx sum^k_m=0fracx(0)(Mt)^mmmathcalM^mx(0)rangle + sum^k-1_n=1fracb(Mt)^n-1tnmathcalM^n-1brangle","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"To bring about the above transformation, we use the quldecircuit.","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"<: LDEMSAlgHHL: LDE algorithm based on HHL\nQuEuler\nQuLeapfrog\nQuAB2\nQuAB3\nQuAB4","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"The HHL algorithm is used for solving a system of linear equations. One can model multistep methods as linear equations, which then can be simulated through HHL.","category":"page"},{"location":"tutorial/lin.html#Usage-1","page":"Linear Differential Equations","title":"Usage","text":"","category":"section"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"Firstly, we need to define a QuLDEProblem for matrix M (may be time dependent), initial vector x and vector b (may be time dependent). tspan is the time interval.","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"using QuDiffEq\nusing OrdinaryDiffEq, Test\nusing Random\nusing LinearAlgebra\n\nsiz = 2\nM = rand(ComplexF64,siz,siz)\nb = normalize!(rand(ComplexF64, siz))\nx = normalize!(rand(ComplexF64, siz))\ntspan = (0.0,0.4)\n\nqprob = QuLDEProblem(M,b,x,tspan)\nqprob","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"To solve the problem we use solve() after deciding on an algorithm e.g. alg = QuAB3() . Here, is an example for QuLDE.","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"alg = QuLDE()\nres = solve(qprob,alg)\nres","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"Let's compare the result with a Tsit5() from OrdinaryDiffEq","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"f(u,p,t) = M*u + b;\nprob = ODEProblem(f, x, tspan)\n\nsol = solve(prob, Tsit5(), dt = 0.1, adaptive = false)\ns = sol.u[end]\n@test isapprox.(s, res, atol = 0.02) |> all","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"Note : QuLDE works only with constant M and b. There is no such restriction on the other algorithms.","category":"page"},{"location":"man/taylor.html#Taylor-Truncation-1","page":"Taylor Truncation","title":"Taylor Truncation","text":"","category":"section"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Taylor truncation based Hamiltonian simulation (https://arxiv.org/abs/1412.4687) has many clear advantages. It has better complexity dependence on the precision and allows a greater range of Hamiltonians to be simulated.","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"The package provides circuits for five kinds of problems:","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Unitary Taylor simulation\nNon-unitary Taylor simulation\nUnitary QuLDE Problem\nNon-unitary QuLDEProblem\nSolution by linearising a non-linear differential equation","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"To simulate the following the algorithm, simulates the Taylor expansion of e^iHt upto k orders.","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"u(t) = e^iHtu(0)","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"We have,","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"x(t)rangle approx sum^k_m=0fracx(0)(Mt)^mmmathcalM^mx(0)rangle","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"where M = iH and M = MmathcalM","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"There are two cases to consider:","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"mathcalM is unitary. In addition to the vector state register, we have T = log_2(k+1) ancillary bits. The ancilla is in 0 to begin with. The VS1 block acts on the ancilla register to generate an appropriate superpostion (sum^k_m=0fracx(0)(Mt)^mm). These bits then control the multiplication of mathcalM. mathcalM^j block is control-multiplied by j in the ancilla register. VS1' is the adjoint of VS1 and it un-computes the ancilla. After the un-computation we obtain the desired result in all zero ancilla bits.\nmathcalM is non-unitary. mathcalM is expressed as a linear combination of four (at most) unitary  i.e. mathcalM =sum_i 12 F_i. We have two registers of sizes k and 2k. These registers participate in control-multiplications, as control bits. VS1 behaves differently to that in the unitary case. In the first register, states with j 1's (where j in 01k) are raised to probability amplitudes equal to the term with the j^th power in the summation above, while rest of the states are given zero probability. The mappings used is m = 2^k - 2^j , m corresponds to the basis state in the first register. This register governs the the power F_i need to be raised. The second register is superposed by VT, where each new state corresponds to an F-i. When un-computed and measured in the zero state ancilla state, we obtain the desired result.","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Modules = [QuDiffEq]\nPages  = [\"TaylorTrunc.jl\",]","category":"page"},{"location":"man/taylor.html#QuDiffEq.TaylorParam","page":"Taylor Truncation","title":"QuDiffEq.TaylorParam","text":"TaylorParam(k::Int, t::L, H::Matrix, x::Array{CPType,1})\n\nAssigns values to parameters required for Taylor series based Hamiltonian simulation.\n\n* k : sets order of Taylor series expansion\n* t : time of evolution\n* H : Hamiltonian\n* x : intial vector\n\nTaylorParam(k::Int,t::L,prob::QuLDEProblem{uType, tType, isinplace, F, P, T})\n\n* k : sets order of Taylor series expansion\n* t : time of evolution\n* prob : wrapper for Linear differential equation problems (contains H, x, b)\n\n\n\n\n\n","category":"type"},{"location":"man/taylor.html#QuDiffEq.circuit_ends-Union{Tuple{CPType}, Tuple{Int64,TaylorParam{CPType,false,L,HM} where HM where L,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_ends","text":"circuit_ends(n::Int, blk::TaylorParam{CPType, false}, VS1::AbstractMatrix, VS2::AbstractMatrix, VT::AbstractMatrix)\n\nGenerates the part of circuit that computes and decomputes the superposition of the ancilla bits, in non-unitary H quldecircuit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_ends-Union{Tuple{CPType}, Tuple{Int64,TaylorParam{CPType,false,L,HM} where HM where L,AbstractArray{T,2} where T,AbstractArray{T,2} where T}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_ends","text":"circuit_ends(n::Int, blk::TaylorParam{CPType, false}, VS1::AbstractMatrix, VT::AbstractMatrix)\n\nGenerates the part of circuit that computes and decomputes the superposition of the ancilla bits, in non-unitary H taylorcircuit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_ends-Union{Tuple{CPType}, Tuple{Int64,TaylorParam{CPType,true,L,HM} where HM where L,AbstractArray{T,2} where T,AbstractArray{T,2} where T}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_ends","text":"circuit_ends(n::Int, blk::TaylorParam{CPType, true}, VS1::AbstractMatrix, VS2::AbstractMatrix)\n\nGenerates the part of circuit that computes and decomputes the superposition of the ancilla bits, in unitary H quldecircuit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_ends-Union{Tuple{CPType}, Tuple{Int64,TaylorParam{CPType,true,L,HM} where HM where L,AbstractArray{T,2} where T}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_ends","text":"circuit_ends(n::Int, blk::TaylorParam{CPType, true}, VS1::AbstractMatrix)\n\nGenerates the part of circuit that computes and decomputes the superposition of the ancilla bits, in unitary H taylorcircuit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_intermediate-Union{Tuple{CPType}, Tuple{Int64,Int64,TaylorParam{CPType,false,L,HM} where HM where L}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_intermediate","text":"circuit_intermediate(n::Int, c::Int, blk::TaylorParam{CPType, false})\n\nGenerates the intermediate part of the circuit for non-unitary H.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_intermediate-Union{Tuple{CPType}, Tuple{Int64,Int64,TaylorParam{CPType,true,L,HM} where HM where L}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_intermediate","text":"circuit_intermediate(n::Int, c::Int, blk::TaylorParam{CPType, true})\n\nGenerates the intermediate part of the circuit for unitary H.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.taylorcircuit-Tuple{Int64,TaylorParam,Array{T,2} where T,Array{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.taylorcircuit","text":"taylorcircuit(n::Int, blk::TaylorParam, VS1::Matrix, VT::Matrix) ->->  ChainBlock{n}\n\nGenerates circuit for a non-unitary H input.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.taylorcircuit-Tuple{Int64,TaylorParam,Array{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.taylorcircuit","text":"taylorcircuit(n::Int, blk::TaylorParam, VS1::Matrix) ->  ChainBlock{n}\n\nGenerates circuit for a unitary H input.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.taylorsolve-Union{Tuple{CPType}, Tuple{Array{CPType,2},Array{CPType,1},Int64,Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.taylorsolve","text":"taylorsolve(H::Array{CPType,2}, x::Vector{CPType}, k::Int, t::Real) -> ArrayReg, CPType\n\nSimulates a Hamiltonian using the Taylor truncation method. Returns the state register and inverse probability of finding it.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.v-Tuple{Int64,Int64,Int64,AbstractArray{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.v","text":"v(n::Int,c::Int, T::Int, V::AbstractMatrix) -> ChainBlock{n}\n\nBuilds T input block. n : total number of qubits V : T input matrix c : starting qubit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.v-Tuple{Int64,Int64,Tuple,Int64,AbstractArray{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.v","text":"v(n::Int,c::Int, j::Tuple, T::Int, V::AbstractMatrix) -> ControlBlock{n}\n\nBuilds a T input, j - control block. n : total number of qubits V : T input matrix c : starting qubit j : control bits tuple\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.calc_vs1-Union{Tuple{CPType}, Tuple{TaylorParam,Array{CPType,1},Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.calc_vs1","text":"calc_vs1(blk::TaylorParam, x::Vector{CPType}, opn::Real) ->  Matrix{CPType}\n\nCalculates VS1 block for Taylor circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.calc_vs2-Union{Tuple{CPType}, Tuple{TaylorParam,Array{CPType,1},Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.calc_vs2","text":"calc_vs2(blk::TaylorParam, x::Vector{CPType}, opn::Real) ->  Matrix{CPType}\n\nopn: operator norm of the input matrix.\n\nCalculates VS2 block for Taylor circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.calc_vt-Union{Tuple{}, Tuple{Type{CPType}}, Tuple{CPType}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.calc_vt","text":"calc_vt(T)\n\ncalc_vt(::Type{CPType}) -> Matrix{CPType}\n\nGenerates VT block for non-unitary Taylor circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.unitary_decompose-Union{Tuple{Array{T,2}}, Tuple{T}} where T","page":"Taylor Truncation","title":"QuDiffEq.unitary_decompose","text":"unitary_decompose(H::Array{T,2}) -> Array{Array{T,2},1}\n\nGenerates a linear compostion of unitary matrices for argument H.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#Quantum-Linear-Differential-Equation-1","page":"Taylor Truncation","title":"Quantum Linear Differential Equation","text":"","category":"section"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"A linear differential equation is written as","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":" fracdxdt = Mx + b","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"M is an arbitrary N × N matrix, x and b are N dimensional vectors.","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"The modified version of the taylorcircuit is employed here. The transformation over x is the same as in the taylorcircuit, but there is simultaneous transformation over b as well. There is an additional ancillary bit that allows the distinction between x and b. This superpostion is brought about by V matrix. Like VS1 in taylorcircuit, VS2 facilitates the transformation over b in the simulation.","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Modules = [QuDiffEq]\nPages  = [\"QuLDE.jl\"]","category":"page"},{"location":"man/taylor.html#QuDiffEq.quldecircuit-Tuple{Int64,TaylorParam,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.quldecircuit","text":"quldecircuit(n::Int,blk::TaylorParam,VS1::AbstractMatrix,VS2::AbstractMatrix,VT::AbstractMatrix) -> ChainBlock{n}\n\nGenerates circuit for solving linear differental equations for a non-unitary H input.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.quldecircuit-Tuple{Int64,TaylorParam,AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.quldecircuit","text":"quldecircuit(n::Int,blk::TaylorParam,VS1::AbstractMatrix,VS2::AbstractMatrix) -> ChainBlock{n}\n\nGenerates circuit for solving linear differental equations for a unitary H input.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#Quantum-Non-linear-Differential-Equation-1","page":"Taylor Truncation","title":"Quantum Non-linear Differential Equation","text":"","category":"section"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"The non-linear solver constitutes two sub-routines. Firstly, the function transform sub-routine, which employs of the taylorcircuit. The function transform lets us map z to P(z), where P is a quadratic polynomial. Secondly, the forward Euler method. The polynomial here is : z + hf(z). f is the derivative.","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Modules = [QuDiffEq]\nPages  = [\"QuNLDE.jl\"]","category":"page"},{"location":"man/taylor.html#QuDiffEq.euler_matrix-Union{Tuple{CPType}, Tuple{Array{CPType,2},Array{CPType,1},Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.euler_matrix","text":"euler_matrix(A::Matrix{CPType},b::Vector{CPType},h::Real) -> Matrix\n\nGenerates matrix for forward Euler iteration.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.euler_matrix_update-Union{Tuple{CPType}, Tuple{Array{CPType,2},Array{CPType,1},Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.euler_matrix_update","text":"euler_matrix(A::Matrix{CPType},b::Vector{CPType},h::Real) -> Matrix\n\nUpdates euler matrix for forward Euler iteration.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.func_transform","page":"Taylor Truncation","title":"QuDiffEq.func_transform","text":"func_transform(A::Matrix, x::Vector, k::Int) -> ArrayReg, <: Complex\n\nFunction transform sub-routine. Returns state register and inverse probability of finding  it.\n\n\n\n\n\n","category":"function"},{"location":"man/taylor.html#QuDiffEq.make_hermitian-Tuple{Array{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.make_hermitian","text":"make_hermitian(A::Matrix) -> Matrix\n\nReturns hermitian matrix containing A.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.make_input_vector-Union{Tuple{Array{T,1}}, Tuple{T}} where T","page":"Taylor Truncation","title":"QuDiffEq.make_input_vector","text":"make_input_vector(x::Vector{T}) -> Vector{T}\n\nGenerates input vector for QuNLDE iterations.\n\n\n\n\n\n","category":"method"},{"location":"index.html#QuDiffEq-1","page":"Home","title":"QuDiffEq","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"QuDiffEq is a package for solving differential equations using quantum algorithms. It makes use of the Yao.jl, a quantum simulator in Julia.","category":"page"},{"location":"index.html#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Quantum algorithms for linear differential equation\nBased on  HHL.\nBased on Truncated Taylor series\nQuantum algorithm for non-linear differential equation","category":"page"},{"location":"index.html#Tutorials-1","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial/lin.md\",\n    \"tutorial/nlin.md\"\n]\nDepth = 2","category":"page"},{"location":"index.html#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n    \"man/algs.md\"\n    \"man/taylor.md\"\n]\nDepth = 2","category":"page"},{"location":"tutorial/nlin.html#Non-linear-Differential-Equations-1","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"","category":"section"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"The problem at hand is a set of differential equations. For simplicity, we consider a two variable set.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"beginarrayrcl fracdxdt  =  f_1(xy)  fracdydt = f_2(xy)endarray","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"QuDiffEq has two algorithms for solving non-linear differential equations:","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"QuNLDE: Uses function transformation and the forward Euler method. (quadratic differential equations only)","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"The algorithm makes use of two sub-routines :","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"A function transformation routine - this is a mapping from z = (xy) to a polynomial, P(z) . The function transformation is done using a Hamiltonian simulation. The Taylor Truncation method is used here.\nA differential equations solver - Forward Euler is used for this purpose. We make use of the mapping, z rightarrow z + hf(z)","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"The functions f_i being quadratic can be expressed as a sum of monomials with coefficients alpha_i ^kl.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"f_i = sum_kl = 0 rightarrow n alpha_i^kl z_k z_l","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"z_0is equal to 1. To begin, we encode the vector z , after normalising it, in a state","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"phirangle = frac1sqrt2 0rangle + frac1sqrt2 zrangle","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"with zrangle = sum z_k krangle","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"The tensor product, phiranglephirangle gives us the a set of all possible monomials in a quadratic equation.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"phiranglephirangle = frac12 0rangle + frac12 sum_kl = 0^n z_k z_lkrangle lrangle","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"What's required now is an operator that assigns corresponding coefficients to each monomial. We define an operator A,","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"A = sum_ikl = 0^na_i^kli0kl","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"a_0^kl = 1 , for k=l=0 , and is zero otherwise. A acting on phiranglephirangle gives us the desired result","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"A phiranglephirangle = sum_ikl = 0^na_i^klz_k z_li0","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"For efficient simulation, the mapping has to be sparse in nature. In general, the functions f_iwill not be measure preserving i.e. they do not preserve the norm of their arguments. In that case, the operator needs to be adjusted by appropriately multiplying its elements by  ||z|| or ||z||^2.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"To actually carry out the simulation, we need to build a hermitian operator containing A. A well-known trick is to write the hamiltonian H =iAotimes10+iA^ 01 (this is von Neumann measurement prescription).  is simulated (using Taylor Truncation method). The resulting state is post-selected 1rangle on to precisely get the what we are looking for.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"QuLDE: Linearises the differential equation at every iteration.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"The system is linearised about the point (x^*y^*). We obtain the equation,","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"fracdDelta udt = J * Delta u + b","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"with","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"J = beginpmatrix\nfracpartial f_1partial x  fracpartial f_1partial y \nfracpartial f_2partial x fracpartial f_2partial y\nendpmatrix","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"b = beginpmatrix\n f_1(x^*y^*)\nf_2(x^*y^*)\nendpmatrix","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"where Delta u is naturally zero. We then have, Delta u_new = (e^Jt - I)J^-1b. This equation is simulated with quldecircuit.","category":"page"},{"location":"tutorial/nlin.html#Usage-1","page":"Non-linear Differential Equations","title":"Usage","text":"","category":"section"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"Let's say we want to solve the following set of differential equations.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"beginarrayrcl fracdz_1dt  =  z_2 - 3 z_1^2  fracdz_2dt  = -z_2^2 - z_1 z_2 endarray","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"Let's take the time interval to be from 0.0 to 0.4. We define the in initial vector randomly.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"using QuDiffEq\nusing OrdinaryDiffEq\nusing Random\nusing LinearAlgebra\n\ntspan = (0.0,0.4)\nx = [0.6, 0.8]","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"For QuNLDE, we need to define a <: QuODEProblem. At present, we use only QuLDEProblem as a Qu problem wrapper. QuNLDE can solve only quadratic differential equations. A is the coefficient matrix for the quadratic differential equation.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"N = 2 # size of the input vector\nsiz = nextpow(2, N + 1)\n\nA = zeros(ComplexF32,2^(siz),2^(siz));\nA[1,1] = ComplexF32(1);\nA[5,3] = ComplexF32(1);\nA[5,6] = ComplexF32(-3);\nA[9,11] = ComplexF32(-1);\nA[9,7] = ComplexF32(-1);","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"qprob = QuLDEProblem(A,x,tspan);\n\nTo solve the problem we use `solve()`","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"julia res = solve(qprob,QuNLDE(), dt = 0.1);","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"Comparing the result with `Euler()`\n","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"julia","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"function f(du,u,p,t)     du[1] = -3u[1]^2 + u[2]     du[2] = -u[2]^2 - u[1]u[2] end","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"prob = ODEProblem(f, x, tspan) sol = solve(prob, Euler(), dt = 0.1, adaptive = false)","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"using Plots;","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"plot(sol.t,real.(res),lw = 1,label=\"QuNLDE()\") plot!(sol,lw = 3, ls=:dash,label=\"Euler()\")","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"\n![](docs/assets/figures/QuNLDE-plot.svg)\n\n- For `QuLDE`, the problem is defined as a `ODEProblem`, similar to that in OrdinaryDiffEq.jl . `f` is the differential equation written symbolically. We can use prob from the previous case itself.\n","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"julia res = solve(prob,QuLDE(),dt = 0.1)","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"julia sol = solve(prob, Tsit5(), dt = 0.1, adaptive = false)","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"using Plots plot(sol.t,real.(res),lw = 1,label=\"QuNLDE()\") plot!(sol,lw = 3, ls=:dash,label=\"Tsit5()\") ``` (Image: )","category":"page"}]
}
