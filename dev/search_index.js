var documenterSearchIndex = {"docs":
[{"location":"man/algs.html#Quantum-Algorithms-for-Differential-Equations-1","page":"Quantum Algorithms for Differential Equations","title":"Quantum Algorithms for Differential Equations","text":"","category":"section"},{"location":"man/algs.html#Taylor-truncation-based-algorithms-1","page":"Quantum Algorithms for Differential Equations","title":"Taylor truncation based algorithms","text":"","category":"section"},{"location":"man/algs.html#","page":"Quantum Algorithms for Differential Equations","title":"Quantum Algorithms for Differential Equations","text":"QuDiffEq.QuLDE\nQuDiffEq.QuNLDE","category":"page"},{"location":"man/algs.html#QuDiffEq.QuLDE","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuLDE","text":"QuLDE <: QuODEAlgorithm\n\nLinear differential equation solvers (non-HHL)     * k : order of Taylor series expansion\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuNLDE","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuNLDE","text":"QuNLDE <: QuODEAlgorithm\n\nLinear differential equation solvers (non-HHL)     * k : order of Taylor series expansion     * ϵ : precision\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#HHL-based-algorithms-1","page":"Quantum Algorithms for Differential Equations","title":"HHL based algorithms","text":"","category":"section"},{"location":"man/algs.html#","page":"Quantum Algorithms for Differential Equations","title":"Quantum Algorithms for Differential Equations","text":"The following algorithms are in the reference, arxiv.org/abs/1010.2745v2 .","category":"page"},{"location":"man/algs.html#","page":"Quantum Algorithms for Differential Equations","title":"Quantum Algorithms for Differential Equations","text":"QuDiffEq.LDEMSAlgHHL\nQuDiffEq.QuEuler\nQuDiffEq.QuLeapfrog\nQuDiffEq.QuAB2\nQuDiffEq.QuAB3\nQuDiffEq.QuAB4","category":"page"},{"location":"man/algs.html#QuDiffEq.LDEMSAlgHHL","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.LDEMSAlgHHL","text":"LDEMSAlgHHL <: QuODEAlgorithm\n\nMulti-step methods based on HHL\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuEuler","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuEuler","text":"QuEuler{T} <: LDEMSAlgHHL\n\nEuler Method using HHL (1-step method)\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuLeapfrog","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuLeapfrog","text":"QuLeapfrog{T} <: LDEMSAlgHHL\n\nLeapfrog Method using HHL (2-step method)\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuAB2","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuAB2","text":"QuAB2{T} <: LDEMSAlgHHL\n\nAB2 Method using HHL (2-step method)\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuAB3","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuAB3","text":"QuAB3{T} <: LDEMSAlgHHL\n\nAB3 Method using HHL (3-step method)\n\n\n\n\n\n","category":"type"},{"location":"man/algs.html#QuDiffEq.QuAB4","page":"Quantum Algorithms for Differential Equations","title":"QuDiffEq.QuAB4","text":"QuAB4{T} <: LDEMSAlgHHL\n\nAB4 Method using HHL (4-step method)\n\n\n\n\n\n","category":"type"},{"location":"tutorial/lin.html#Linear-Differential-Equations-1","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"","category":"section"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"A linear differential equation is written as","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":" fracdxdt = Mx + b","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"M is an arbitrary N × N matrix, x and b are N dimensional vectors.","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"QuDiffEq allows for the following methods of solving a linear differential equation:","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"QuLDE: LDE algorithm based on Taylor Truncation. This method evaluates the vector at the last time step, without going through the intermediate steps, unlike other solvers.\n<: LDEMSAlgHHL: LDE algorithm based on HHL\nQuEuler\nQuLeapfrog\nQuAB2\nQuAB3\nQuAB4","category":"page"},{"location":"tutorial/lin.html#Usage-1","page":"Linear Differential Equations","title":"Usage","text":"","category":"section"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"Firstly, we need to define a QuLDEProblem for matrix M (may be time dependent), initial vector x and vector b (may be time dependent). tspan is the time interval.","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"using QuDiffEq\nusing OrdinaryDiffEq, Test\nusing Random\nusing LinearAlgebra\n\nsiz = 2\nM = rand(ComplexF64,siz,siz)\nb = normalize!(rand(ComplexF64, siz))\nx = normalize!(rand(ComplexF64, siz))\ntspan = (0.0,0.4)\n\nqprob = QuLDEProblem(M,b,x,tspan)\nqprob","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"To solve the problem we use solve() after deciding on an algorithm e.g. alg = QuAB3() . Here, is an example for QuLDE.","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"alg = QuLDE()\nres = solve(qprob,alg)\nres","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"Let's compare the result with a Tsit5() from OrdinaryDiffEq","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"f(u,p,t) = M*u + b;\nprob = ODEProblem(f, x, tspan)\n\nsol = solve(prob, Tsit5(), dt = 0.1, adaptive = false)\ns = sol.u[end]\n@test isapprox.(s, res, atol = 0.02) |> all","category":"page"},{"location":"tutorial/lin.html#","page":"Linear Differential Equations","title":"Linear Differential Equations","text":"Note : QuLDE works only with constant M and b. There is no such restriction on the other algorithms.","category":"page"},{"location":"man/taylor.html#Taylor-Truncation-1","page":"Taylor Truncation","title":"Taylor Truncation","text":"","category":"section"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Taylor truncation based Hamiltonian simulation (https://arxiv.org/abs/1412.4687) has many clear advantages. It has better complexity dependence on the precision and allows a greater range of Hamiltonians to be simulated.","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"The package provides circuits for five kinds of problems:","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Unitary Taylor simulation\nNon-unitary Taylor simulation\nUnitary QuLDE Problem\nNon-unitary QuLDEProblem\nSolution by linearising a non-linear differential equation","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Modules = [QuDiffEq]\nPages  = [\"TaylorTrunc.jl\",]","category":"page"},{"location":"man/taylor.html#QuDiffEq.TaylorParam","page":"Taylor Truncation","title":"QuDiffEq.TaylorParam","text":"TaylorParam(k::Int, t::L, H::Matrix, x::Array{CPType,1})\n\nAssigns values to parameters required for Taylor series based Hamiltonian simulation.\n\n* k : sets order of Taylor series expansion\n* t : time of evolution\n* H : Hamiltonian\n* x : intial vector\n\nTaylorParam(k::Int,t::L,prob::QuLDEProblem{uType, tType, isinplace, F, P, T})\n\n* k : sets order of Taylor series expansion\n* t : time of evolution\n* prob : wrapper for Linear differential equation problems (contains H, x, b)\n\n\n\n\n\n","category":"type"},{"location":"man/taylor.html#QuDiffEq.circuit_ends-Union{Tuple{CPType}, Tuple{Int64,TaylorParam{CPType,false,L,HM} where HM where L,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_ends","text":"circuit_ends(n::Int, blk::TaylorParam{CPType, false}, VS1::AbstractMatrix, VS2::AbstractMatrix, VT::AbstractMatrix)\n\nGenerates the part of circuit that computes and decomputes the superposition of the ancilla bits, in non-unitary H quldecircuit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_ends-Union{Tuple{CPType}, Tuple{Int64,TaylorParam{CPType,false,L,HM} where HM where L,AbstractArray{T,2} where T,AbstractArray{T,2} where T}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_ends","text":"circuit_ends(n::Int, blk::TaylorParam{CPType, false}, VS1::AbstractMatrix, VT::AbstractMatrix)\n\nGenerates the part of circuit that computes and decomputes the superposition of the ancilla bits, in non-unitary H taylorcircuit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_ends-Union{Tuple{CPType}, Tuple{Int64,TaylorParam{CPType,true,L,HM} where HM where L,AbstractArray{T,2} where T,AbstractArray{T,2} where T}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_ends","text":"circuit_ends(n::Int, blk::TaylorParam{CPType, true}, VS1::AbstractMatrix, VS2::AbstractMatrix)\n\nGenerates the part of circuit that computes and decomputes the superposition of the ancilla bits, in unitary H quldecircuit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_ends-Union{Tuple{CPType}, Tuple{Int64,TaylorParam{CPType,true,L,HM} where HM where L,AbstractArray{T,2} where T}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_ends","text":"circuit_ends(n::Int, blk::TaylorParam{CPType, true}, VS1::AbstractMatrix)\n\nGenerates the part of circuit that computes and decomputes the superposition of the ancilla bits, in unitary H taylorcircuit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_intermediate-Union{Tuple{CPType}, Tuple{Int64,Int64,TaylorParam{CPType,false,L,HM} where HM where L}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_intermediate","text":"circuit_intermediate(n::Int, c::Int, blk::TaylorParam{CPType, false})\n\nGenerates the intermediate part of the circuit for non-unitary H.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.circuit_intermediate-Union{Tuple{CPType}, Tuple{Int64,Int64,TaylorParam{CPType,true,L,HM} where HM where L}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.circuit_intermediate","text":"circuit_intermediate(n::Int, c::Int, blk::TaylorParam{CPType, true})\n\nGenerates the intermediate part of the circuit for unitary H.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.taylorcircuit-Tuple{Int64,TaylorParam,Array{T,2} where T,Array{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.taylorcircuit","text":"taylorcircuit(n::Int, blk::TaylorParam, VS1::Matrix, VT::Matrix) ->->  ChainBlock{n}\n\nGenerates circuit for a non-unitary H input.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.taylorcircuit-Tuple{Int64,TaylorParam,Array{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.taylorcircuit","text":"taylorcircuit(n::Int, blk::TaylorParam, VS1::Matrix) ->  ChainBlock{n}\n\nGenerates circuit for a unitary H input.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.taylorsolve-Union{Tuple{CPType}, Tuple{Array{CPType,2},Array{CPType,1},Int64,Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.taylorsolve","text":"taylorsolve(H::Array{CPType,2}, x::Vector{CPType}, k::Int, t::Real) -> ArrayReg, CPType\n\nSimulates a Hamiltonian using the Taylor truncation method. Returns the state register and inverse probability of finding it.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.v-Tuple{Int64,Int64,Int64,AbstractArray{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.v","text":"v(n::Int,c::Int, T::Int, V::AbstractMatrix) -> ChainBlock{n}\n\nBuilds T input block. n : total number of qubits V : T input matrix c : starting qubit\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.v-Tuple{Int64,Int64,Tuple,Int64,AbstractArray{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.v","text":"v(n::Int,c::Int, j::Tuple, T::Int, V::AbstractMatrix) -> ControlBlock{n}\n\nBuilds a T input, j - control block. n : total number of qubits V : T input matrix c : starting qubit j : control bits tuple\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.calc_vs1-Union{Tuple{CPType}, Tuple{TaylorParam,Array{CPType,1},Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.calc_vs1","text":"calc_vs1(blk::TaylorParam, x::Vector{CPType}, opn::Real) ->  Matrix{CPType}\n\nCalculates VS1 block for Taylor circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.calc_vs2-Union{Tuple{CPType}, Tuple{TaylorParam,Array{CPType,1},Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.calc_vs2","text":"calc_vs2(blk::TaylorParam, x::Vector{CPType}, opn::Real) ->  Matrix{CPType}\n\nopn: operator norm of the input matrix.\n\nCalculates VS2 block for Taylor circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.calc_vt-Union{Tuple{}, Tuple{Type{CPType}}, Tuple{CPType}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.calc_vt","text":"calc_vt(T)\n\ncalc_vt(::Type{CPType}) -> Matrix{CPType}\n\nGenerates VT block for non-unitary Taylor circuit.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.unitary_decompose-Union{Tuple{Array{T,2}}, Tuple{T}} where T","page":"Taylor Truncation","title":"QuDiffEq.unitary_decompose","text":"unitary_decompose(H::Array{T,2}) -> Array{Array{T,2},1}\n\nGenerates a linear compostion of unitary matrices for argument H.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#Linear-Differential-Equation-Solver-1","page":"Taylor Truncation","title":"Linear Differential Equation Solver","text":"","category":"section"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"A linear differential equation has the form :","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":" fracdxdt = Mx + b","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Mis an arbitrary N  N matrix,xand bare dimensional vectors. The exact solution for x(t) is give by -","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":" x(t) = e^Mtx(0) + (e^Mt - I)M^-1b","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"This can be Taylor expanded up to the k^thorder as -","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"x(t) approx sum^k_m=0frac(Mt)^mmx(0) + sum^k-1_n=1frac(Mt)^n-1tnb","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"The vectors x(0) and b are encoded as state - x(0)rangle = sum_i fracx_ix irangle and brangle = sum_i fracb_ib irangle with i rangleas the computational basis states. We can also write M as M = MmathcalM. We then get:","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"x(t)rangle approx sum^k_m=0fracx(0)(Mt)^mmmathcalM^mx(0)rangle + sum^k-1_n=1fracb(Mt)^n-1tnmathcalM^n-1brangle","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"The quldecircuit effects this transformation on the input state to obtain x(t).","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Modules = [QuDiffEq]\nPages  = [\"QuLDE.jl\"]","category":"page"},{"location":"man/taylor.html#QuDiffEq.quldecircuit-Tuple{Int64,TaylorParam,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.quldecircuit","text":"quldecircuit(n::Int,blk::TaylorParam,VS1::AbstractMatrix,VS2::AbstractMatrix,VT::AbstractMatrix) -> ChainBlock{n}\n\nGenerates circuit for solving linear differental equations for a non-unitary H input.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.quldecircuit-Tuple{Int64,TaylorParam,AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.quldecircuit","text":"quldecircuit(n::Int,blk::TaylorParam,VS1::AbstractMatrix,VS2::AbstractMatrix) -> ChainBlock{n}\n\nGenerates circuit for solving linear differental equations for a unitary H input.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#Non-linear-Differential-Equation-Solver-1","page":"Taylor Truncation","title":"Non-linear Differential Equation Solver","text":"","category":"section"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"The non-linear solver constitutes two sub-routines. Firstly, the function transform sub-routine, which employs of the taylorcircuit. The function transform lets us map z to P(z), where P is a quadratic polynomial. Secondly, the forward Euler method.","category":"page"},{"location":"man/taylor.html#","page":"Taylor Truncation","title":"Taylor Truncation","text":"Modules = [QuDiffEq]\nPages  = [\"QuNLDE.jl\"]","category":"page"},{"location":"man/taylor.html#QuDiffEq.euler_matrix-Union{Tuple{CPType}, Tuple{Array{CPType,2},Array{CPType,1},Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.euler_matrix","text":"euler_matrix(A::Matrix{CPType},b::Vector{CPType},h::Real) -> Matrix\n\nGenerates matrix for forward Euler iteration.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.euler_matrix_update-Union{Tuple{CPType}, Tuple{Array{CPType,2},Array{CPType,1},Real}} where CPType","page":"Taylor Truncation","title":"QuDiffEq.euler_matrix_update","text":"euler_matrix(A::Matrix{CPType},b::Vector{CPType},h::Real) -> Matrix\n\nUpdates euler matrix for forward Euler iteration.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.func_transform","page":"Taylor Truncation","title":"QuDiffEq.func_transform","text":"func_transform(A::Matrix, x::Vector, k::Int) -> ArrayReg, <: Complex\n\nFunction transform sub-routine. Returns state register and inverse probability of finding  it.\n\n\n\n\n\n","category":"function"},{"location":"man/taylor.html#QuDiffEq.make_hermitian-Tuple{Array{T,2} where T}","page":"Taylor Truncation","title":"QuDiffEq.make_hermitian","text":"make_hermitian(A::Matrix) -> Matrix\n\nReturns hermitian matrix containing A.\n\n\n\n\n\n","category":"method"},{"location":"man/taylor.html#QuDiffEq.make_input_vector-Union{Tuple{Array{T,1}}, Tuple{T}} where T","page":"Taylor Truncation","title":"QuDiffEq.make_input_vector","text":"make_input_vector(x::Vector{T}) -> Vector{T}\n\nGenerates input vector for QuNLDE iterations.\n\n\n\n\n\n","category":"method"},{"location":"index.html#QuDiffEq-1","page":"Home","title":"QuDiffEq","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"A General Purpose Quantum Computation Simulation Framework","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"QuDiffEq is a package for solving differential equations using quantum algorithms. It makes use of the Yao.jl, a quantum simulator in Julia.","category":"page"},{"location":"index.html#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Quantum algorithms for linear differential equation\nBased on  HHL.\nBased on Truncated Taylor series\nQuantum algorithm for non-linear differential equation","category":"page"},{"location":"index.html#Tutorials-1","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial/lin.md\",\n    \"tutorial/nlin.md\"\n]\nDepth = 2","category":"page"},{"location":"index.html#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n    \"man/algs.md\"\n    \"man/taylor.md\"\n]\nDepth = 2","category":"page"},{"location":"tutorial/nlin.html#Non-linear-Differential-Equations-1","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"","category":"section"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"QuDiffEq has two algorithms for solving non-linear differential equations:","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"QuNLDE: Uses function transformation and the forward Euler method.\nQuLDE: Linearises the differential equation at every iteration.","category":"page"},{"location":"tutorial/nlin.html#Usage-1","page":"Non-linear Differential Equations","title":"Usage","text":"","category":"section"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"Let's say we want to solve the following set of differential equations.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"beginarrayrcl fracdz_1dt  =  z_2 - 3 z_1^2  fracdz_2dt  = -z_2^2 - z_1 z_2 endarray","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"Let's take the time interval to be from 0.0 to 0.4. We define the in initial vector randomly.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"using QuDiffEq\nusing OrdinaryDiffEq\nusing Random\nusing LinearAlgebra\n\ntspan = (0.0,0.4)\nx = normalize!(rand(2))","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"For QuNLDE, we need to define a <: QuODEProblem. At present, we use only QuLDEProblem as a Qu problem wrapper. QuNLDE can solve only quadratic differential equations. A is the coefficient matrix for the quadratic differential equation.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"N = 2 # size of the input vector\nsiz = nextpow(2, N + 1)\n\nA = zeros(ComplexF32,2^(siz),2^(siz));\nA[1,1] = ComplexF32(1);\nA[5,3] = ComplexF32(1);\nA[5,6] = ComplexF32(-3);\nA[9,11] = ComplexF32(-1);\nA[9,7] = ComplexF32(-1);\nnothing #hide","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"qprob = QuLDEProblem(A,x,tspan)\nqprob","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"To solve the problem we use solve()","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"res = solve(qprob,QuNLDE(), dt = 0.1)\nres","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"Comparing the result with Euler()","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"\nfunction f(du,u,p,t)\n    du[1] = -3*u[1]^2 + u[2]\n    du[2] = -u[2]^2 - u[1]*u[2]\nend\n\nprob = ODEProblem(f, x, tspan)\nsol = solve(prob, Euler(), dt = 0.1, adaptive = false)\n\nusing Plots;\n\nplot(sol.t,real.(res),lw = 1,label=\"QuNLDE()\")\nplot!(sol,lw = 3, ls=:dash,label=\"Euler()\")\nsavefig(\"QuNLDE-plot.svg\"); nothing # hide","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"(Image: )","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"For QuLDE, the problem is defined as a ODEProblem, similar to that in OrdinaryDiffEq.jl . f is the differential equation written symbolically. We can use prob from the previous case itself.","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"res = solve(prob,QuLDE(),dt = 0.1)\n\nsol = solve(prob, Tsit5(), dt = 0.1, adaptive = false)\n\nusing Plots\nplot(sol.t,real.(res),lw = 1,label=\"QuNLDE()\")\nplot!(sol,lw = 3, ls=:dash,label=\"Tsit5()\")\nsavefig(\"QuLDE-plot.svg\"); nothing # hide","category":"page"},{"location":"tutorial/nlin.html#","page":"Non-linear Differential Equations","title":"Non-linear Differential Equations","text":"(Image: )","category":"page"}]
}
