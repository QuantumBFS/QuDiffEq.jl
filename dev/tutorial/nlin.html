<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-linear Differential Equations · QuDiffEq.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><h1>QuDiffEq.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="lin.html">Linear Differential Equations</a></li><li class="current"><a class="toctext" href="nlin.html">Non-linear Differential Equations</a><ul class="internal"><li><a class="toctext" href="#QuNLDE-1">QuNLDE</a></li><li><a class="toctext" href="#QuLDE-1">QuLDE</a></li><li><a class="toctext" href="#Usage-1">Usage</a></li></ul></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/algs.html">Quantum Algorithms for Differential Equations</a></li><li><a class="toctext" href="../man/taylor.html">Taylor Truncation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorial</li><li><a href="nlin.html">Non-linear Differential Equations</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/QuDiffEq.jl/blob/master/docs/src/tutorial/nlin.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Non-linear Differential Equations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Non-linear-Differential-Equations-1" href="#Non-linear-Differential-Equations-1">Non-linear Differential Equations</a></h1><p>The problem at hand is a set of differential equations. For simplicity, we consider a two variable set.</p><div>\[\begin{array}{rcl} \frac{dx}{dt} &amp; = &amp; f_1(x,y) \\ \frac{dy}{dt} &amp;=&amp; f_2(x,y)\end{array}\]</div><p><code>QuDiffEq</code> has two algorithms for solving non-linear differential equations.</p><h2><a class="nav-anchor" id="QuNLDE-1" href="#QuNLDE-1">QuNLDE</a></h2><p>Uses function transformation and the forward Euler method. (quadratic differential equations only)</p><p>The algorithm makes use of two sub-routines :</p><ol><li><p>A function transformation routine - this is a mapping from <span>$z = (x,y)$</span> to a polynomial, <span>$P(z)$</span> . The function transformation is done using a Hamiltonian simulation. The <em>Taylor Truncation method</em> is used here.</p></li><li><p>A differential equations solver - Forward Euler is used for this purpose. We make use of the mapping, <span>$z \rightarrow z + hf(z)$</span></p></li></ol><p>The functions <span>$f_i$</span> being quadratic can be expressed as a sum of monomials with coefficients <span>$\alpha_i ^{kl}$</span>.</p><div>\[f_i = \sum_{k,l = 0 \rightarrow n} \alpha_i^{kl} z_k z_l\]</div><p><span>$z_0$</span>is equal to 1. To begin, we encode the vector z , after normalising it, in a state</p><div>\[|\phi\rangle = \frac{1}{\sqrt{2}} |0\rangle + \frac{1}{\sqrt{2}} |z\rangle\]</div><p>with <span>$|z\rangle = \sum z_k |k\rangle$</span></p><p>The tensor product, <span>$|\phi\rangle|\phi\rangle$</span> gives us the a set of all possible monomials in a quadratic equation.</p><div>\[|\phi\rangle|\phi\rangle = \frac{1}{2} |0\rangle + \frac{1}{2} \sum_{k,l = 0}^n z_k z_l|k\rangle |l\rangle\]</div><p>What&#39;s required now is an operator that assigns corresponding coefficients to each monomial. We define an operator <span>$A$</span>,</p><div>\[A = \sum_{i,k,l = 0}^{n}a_i^{kl}|i0⟩⟨kl|\]</div><p><span>$a_0^{kl} = 1$</span> , for <span>$k=l=0$</span> , and is zero otherwise. <span>$A$</span> acting on <span>$|\phi\rangle|\phi\rangle$</span> gives us the desired result</p><div>\[A |\phi\rangle|\phi\rangle = \sum_{i,k,l = 0}^{n}a_i^{kl}z_k z_l|i⟩|0⟩\]</div><p>For efficient simulation, the mapping has to be <em>sparse</em> in nature. In general, the functions <span>$f_i$</span>will not be measure preserving i.e. they do not preserve the norm of their arguments. In that case, the operator needs to be adjusted by appropriately multiplying its elements by  ||z|| or ||z||^2.</p><p>To actually carry out the simulation, we need to build a hermitian operator containing <span>$A$</span>. A well-known trick is to write the hamiltonian <span>$H =−iA\otimes|1⟩⟨0|+iA^† ⊗|0⟩⟨1|$</span> (this is von Neumann measurement prescription).  is simulated (using Taylor Truncation method). The resulting state is post-selected <span>$|1\rangle$</span> on to precisely get the what we are looking for.</p><h2><a class="nav-anchor" id="QuLDE-1" href="#QuLDE-1">QuLDE</a></h2><p>Linearises the differential equation at every iteration.</p><p>The system is linearised about the point <span>$(x^{*},y^{*})$</span>. We obtain the equation,</p><div>\[\frac{d\Delta u}{dt} = J * \Delta u + b\]</div><p>with</p><div>\[J = \begin{pmatrix}
\frac{\partial f_1}{\partial x} &amp; \frac{\partial f_1}{\partial y} \\
\frac{\partial f_2}{\partial x} &amp;\frac{\partial f_2}{\partial y}
\end{pmatrix}\]</div><div>\[b = \begin{pmatrix}
 f_1(x^{*},y^{*})\\
f_2(x^{*},y^{*})
\end{pmatrix}\]</div><p>where <span>$\Delta u$</span> is naturally zero. We then have, <span>$\Delta u_{new} = (e^{Jt} - I)J^{-1}b$</span>. This equation is simulated with <code>quldecircuit</code>.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><p>Let&#39;s say we want to solve the following set of differential equations.</p><div>\[\begin{array}{rcl} \frac{dz_1}{dt} &amp; = &amp; z_2 - 3 z_{1}^{2} \\ \frac{dz_2}{dt}  &amp;=&amp; -z_{2}^{2} - z_1 z_{2} \end{array}\]</div><p>Let&#39;s take the time interval to be from 0.0 to 0.4. We define the in initial vector randomly.</p><pre><code class="language-">using QuDiffEq
using OrdinaryDiffEq
using LinearAlgebra

tspan = (0.0,0.4)
x = [0.6, 0.8]</code></pre><ul><li>For <code>QuNLDE</code>, we need to define a <code>&lt;: QuODEProblem</code>. At present, we use only <code>QuLDEProblem</code> as a Qu problem wrapper. <code>QuNLDE</code> can solve only quadratic differential equations. <code>A</code> is the coefficient matrix for the quadratic differential equation.</li></ul><pre><code class="language-julia">N = 2 # size of the input vector
siz = nextpow(2, N + 1)

A = zeros(ComplexF32,2^(siz),2^(siz));
A[1,1] = ComplexF32(1);
A[5,3] = ComplexF32(1);
A[5,6] = ComplexF32(-3);
A[9,11] = ComplexF32(-1);
A[9,7] = ComplexF32(-1);</code></pre><pre><code class="language-">qprob = QuLDEProblem(A,x,tspan);</code></pre><p>To solve the problem we use <code>solve()</code></p><pre><code class="language-">res = solve(qprob,QuNLDE(), dt = 0.1);</code></pre><p>Comparing the result with <code>Euler()</code></p><pre><code class="language-">function f(du,u,p,t)
    du[1] = -3*u[1]^2 + u[2]
    du[2] = -u[2]^2 - u[1]*u[2]
end

prob = ODEProblem(f, x, tspan)
sol = solve(prob, Euler(), dt = 0.1, adaptive = false)

using Plots;

plot(sol.t,real.(res),lw = 1,label=&quot;QuNLDE()&quot;)
plot!(sol,lw = 3, ls=:dash,label=&quot;Euler()&quot;)</code></pre><p><img src="../assets/figures/QuNLDE-plot.svg" alt/></p><ul><li>For <code>QuLDE</code>, the problem is defined as a <code>ODEProblem</code>, similar to that in OrdinaryDiffEq.jl . <code>f</code> is the differential equation written symbolically. We can use prob from the previous case itself.</li></ul><pre><code class="language-">res = solve(prob,QuLDE(),dt = 0.1)</code></pre><pre><code class="language-">sol = solve(prob, Tsit5(), dt = 0.1, adaptive = false)

using Plots
plot(sol.t,real.(res),lw = 1,label=&quot;QuNLDE()&quot;)
plot!(sol,lw = 3, ls=:dash,label=&quot;Tsit5()&quot;)</code></pre><p><img src="../assets/figures/QuLDE-plot.svg" alt/></p><footer><hr/><a class="previous" href="lin.html"><span class="direction">Previous</span><span class="title">Linear Differential Equations</span></a><a class="next" href="../man/algs.html"><span class="direction">Next</span><span class="title">Quantum Algorithms for Differential Equations</span></a></footer></article></body></html>
